## 📌 Execution Context 동작 원리 (심화 정리)

Execution Context는 JavaScript 코드가 실행되기 위한 **환경 정보 객체**이며,  
모든 코드는 실행 컨텍스트 내부에서 동작한다.

자바스크립트 엔진은 코드를 실행할 때 다음 단계를 따른다:

1. 전역 실행 컨텍스트(Global Execution Context) 생성
2. 함수 호출 시 새로운 실행 컨텍스트 생성
3. Call Stack에 push
4. 실행 종료 시 pop

---

# 🔎 Execution Context 구성 요소

각 실행 컨텍스트는 내부적으로 다음을 가진다:

- LexicalEnvironment
- VariableEnvironment
- ThisBinding

ES5까지는 VariableEnvironment와 LexicalEnvironment가 구분되었지만  
ES6 이후에는 주로 LexicalEnvironment 중심으로 이해한다.

---

# 1️⃣ 생성 단계 (Creation Phase)

코드 실행 전에 먼저 실행 컨텍스트가 생성된다.

## 1. LexicalEnvironment 생성

LexicalEnvironment는 두 가지로 구성된다:

- Environment Record
- Outer Lexical Environment Reference

### 📌 Environment Record
현재 스코프에 선언된 식별자들을 저장한다.

- var
- let
- const
- function 선언문

### 📌 Outer Reference
상위 스코프를 가리키는 참조  
→ 스코프 체인을 형성

---

## 2. VariableEnvironment 생성

초기에는 LexicalEnvironment와 동일하지만,
`var` 선언은 여기에서 관리된다고 이해하면 된다.

- var 변수는 undefined로 초기화
- 함수 선언문은 전체가 메모리에 올라감

---

## 3. this 바인딩 결정

실행 컨텍스트 생성 시 this 값이 결정된다.

- 전역 → window (브라우저) / global (Node)
- 일반 함수 → 호출 방식에 따라 결정
- 화살표 함수 → 상위 스코프의 this를 캡처

---

## 4. Hoisting 발생

Hoisting은 "끌어올려지는 것처럼 보이는 현상"이다.

실제로는 생성 단계에서 메모리에 먼저 등록되는 것.

- var → undefined로 초기화
- let/const → TDZ(Temporal Dead Zone) 존재
- function → 완전한 함수 객체로 초기화

---

# 2️⃣ 실행 단계 (Execution Phase)

이 단계에서 코드가 한 줄씩 실행된다.

- 변수에 값 할당
- 함수 호출
- 표현식 평가

이때 식별자를 찾을 때는:

1. 현재 Environment Record 검색
2. 없으면 Outer Environment로 이동
3. 전역까지 탐색

→ 이것이 **Lexical Scope 기반 스코프 체인 탐색**

---

# 🧠 Call Stack 기반 관리

실행 컨텍스트는 Call Stack으로 관리된다.

예시:

```js
function a() {
  b();
}

function b() {
  console.log("hi");
}

a();
```