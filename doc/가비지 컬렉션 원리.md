## 📌 가비지 컬렉션(Garbage Collection) 원리 정리

가비지 컬렉션(GC)은 **더 이상 사용되지 않는 메모리를 자동으로 회수하는 메커니즘**입니다.
JavaScript(V8), Java, Go 등 대부분의 현대 언어는 GC 기반 메모리 관리 방식을 사용합니다.

---

# 1️⃣ GC의 핵심 개념

## 🔹 왜 필요한가?

C/C++처럼 개발자가 직접 `free()`를 호출하는 방식은:

- 메모리 누수
- 이중 해제(Double free)
- 댕글링 포인터

같은 위험이 존재합니다.

GC는 **"도달 가능성(Reachability)"** 을 기준으로
자동으로 불필요한 메모리를 정리합니다.

---

# 2️⃣ Reachability(도달 가능성) 기준 수거

## 📌 핵심 아이디어

> 어떤 객체가 "Root"로부터 도달 가능하면 살아있다고 판단한다.

---

## 🔹 Root란?

- 전역 객체 (`window`, `global`)
- 현재 실행 중인 함수의 로컬 변수
- 클로저에 의해 참조되는 변수
- 콜스택(Call Stack)에 있는 값들

---

## 🔹 예시

```js
let user = { name: "kim" };
```

```
Root → user → { name: "kim" }
```

→ 도달 가능 → 수거되지 않음

---

```js
let user = { name: "kim" };
user = null;
```

```
Root → user (null)
{ name: "kim" } ← 고립됨
```

→ 도달 불가능 → GC 대상

---

# 3️⃣ Mark and Sweep 알고리즘

가장 기본적인 GC 알고리즘입니다.

---

## 📌 1단계: Mark (표시)

1. Root에서 시작
2. 참조된 모든 객체를 방문
3. 살아있는 객체에 표시(mark)

```
Root
 ├─ A
 │   └─ B
 └─ C
```

→ A, B, C 모두 mark됨

---

## 📌 2단계: Sweep (정리)

힙 전체를 순회하면서

- mark된 객체 → 유지
- mark되지 않은 객체 → 삭제

---

## 📌 시각적 흐름

```
[Heap]
A (marked)
B (marked)
C (marked)
D (unmarked) ← 삭제
E (unmarked) ← 삭제
```

---

## 📌 특징

- 순환 참조도 정리 가능
- 구현이 단순
- Stop-the-world 발생 가능

---

# 4️⃣ 참조 그래프 기반 정리

GC는 내부적으로 **객체 참조 그래프(Object Reference Graph)** 를 사용합니다.

---

## 📌 그래프 구조

- 노드(Node) → 객체
- 간선(Edge) → 참조 관계

---

### 🔹 예시

```js
let a = {};
let b = {};

a.ref = b;
b.ref = a;

a = null;
b = null;
```

그래프:

```
A ↔ B
```

Root와 연결이 끊어짐

→ 둘 다 도달 불가능
→ GC 대상

---

### 📌 왜 Reference Counting은 문제인가?

과거 방식:

```
A ↔ B
```

참조 카운트:

- A: 1
- B: 1

0이 아니므로 수거되지 않음 ❌

---

### 📌 Mark & Sweep은 해결 가능

Root에서 도달 불가
→ mark되지 않음
→ sweep 단계에서 제거됨 ✅

---

# 5️⃣ JavaScript 엔진(V8)의 GC 구조

예: V8 (Chrome, Node.js에서 사용)

---

## 📌 세대별 GC(Generational GC)

### 🔹 Young Generation

- 새로 생성된 객체
- 빠른 Minor GC
- 자주 정리됨

### 🔹 Old Generation

- 오래 살아남은 객체
- Major GC 대상
- 비교적 느림

---

## 📌 왜 세대 분리?

통계적으로:

> 대부분의 객체는 금방 죽는다.

→ Young 영역을 자주 정리하는 것이 효율적

---

# 6️⃣ GC가 발생하는 시점

- 메모리 임계치 도달
- 힙 공간 부족
- 엔진 내부 정책
- 수동 트리거 (`--expose-gc` 옵션)

---

# 7️⃣ Stop-The-World 문제

GC가 실행되는 동안:

```
JS 실행 중단
→ GC 수행
→ 다시 실행
```

이를 **Stop-The-World** 라고 합니다.

---

## 📌 해결 방법 (최신 엔진)

- Incremental GC (조각 단위 정리)
- Concurrent GC (백그라운드 정리)
- Parallel GC (멀티스레드)

V8은 점진적 + 병렬 GC를 사용합니다.

---

# 8️⃣ 메모리 누수 발생 원리

GC가 있다고 해서 누수가 없는 건 아닙니다.

---

## 📌 대표적 누수 케이스

### 🔹 1. 전역 변수

```js
window.cache = {};
```

Root에 계속 연결됨 → 수거 불가

---

### 🔹 2. 클로저

```js
function outer() {
  let bigData = new Array(1000000);

  return function () {
    console.log("hello");
  };
}
```

→ bigData가 참조 유지됨

---

### 🔹 3. DOM 참조 유지

```js
let el = document.getElementById("app");
```

DOM 제거해도 JS 참조가 남아있으면 수거 안 됨

---

# 9️⃣ GC 요약 비교

| 방식               | 순환 참조 처리 | 구현 난이도 |
| ------------------ | -------------- | ----------- |
| Reference Counting | ❌             | 낮음        |
| Mark & Sweep       | ✅             | 중간        |
| Generational GC    | ✅             | 높음        |

---

# 🔟 한 줄 요약

> 가비지 컬렉션은 Root에서 도달 가능한 객체만 유지하고, 나머지를 Mark & Sweep으로 제거하는 참조 그래프 기반 메모리 관리 방식이다.

---
