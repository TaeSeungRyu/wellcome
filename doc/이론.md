
---

# 1️⃣ JavaScript 심화

## ✅ 실행 컨텍스트 & 스코프

### 📌 Execution Context 동작 원리
- 생성 단계 (Creation Phase)
  - VariableEnvironment 생성
  - LexicalEnvironment 생성
  - this 바인딩
  - Hoisting 발생
- 실행 단계 (Execution Phase)
  - 코드 순차 실행
- Call Stack 기반으로 관리

### 📌 Lexical Scope
- 함수가 **선언된 위치** 기준으로 스코프 결정
- 스코프 체인으로 상위 환경 탐색

### 📌 Closure 활용 사례
- 모듈 패턴
- 데이터 은닉
- 메모이제이션
- 이벤트 핸들러에서 상태 유지

---

## ✅ 비동기 처리

### 📌 Event Loop 구조
- Call Stack
- Web APIs
- Task Queue (Macrotask)
- Microtask Queue
- 실행 순서:  
  1. Call Stack 비움  
  2. Microtask 전부 실행  
  3. Macrotask 1개 실행  
  4. 반복

### 📌 Promise & async/await 내부 동작
- Promise는 Microtask Queue에서 처리
- async 함수는 Promise 반환
- await는 비동기 중단 → 이후 코드는 Microtask로 재진입

### 📌 병렬 처리 패턴
- `Promise.all` → 전체 성공 시 resolve
- `Promise.race` → 가장 먼저 완료된 결과
- `Promise.allSettled` → 성공/실패 모두 반환

### 📌 AbortController
- fetch 요청 취소
- 경쟁 요청 처리
- 컴포넌트 unmount 시 요청 정리

---

## ✅ 메모리 & 최적화

### 📌 가비지 컬렉션 원리
- Mark and Sweep
- Reachability 기준 수거
- 참조 그래프 기반 정리

### 📌 메모리 누수 케이스
- 클로저에 불필요한 참조 유지
- 제거되지 않은 이벤트 리스너
- 분리된 DOM 노드 참조 유지
- 타이머 미정리

### 📌 디바운스 / 쓰로틀
- Debounce → 마지막 호출만 실행
- Throttle → 일정 간격으로 실행
- 스크롤/리사이즈 이벤트 최적화에 사용

---

# 2️⃣ 브라우저 동작 원리

## ✅ 렌더링 파이프라인
1. HTML 파싱 → DOM 생성
2. CSS 파싱 → CSSOM 생성
3. Render Tree 생성
4. Layout (Reflow)
5. Paint (Repaint)
6. Composite

### 📌 Reflow vs Repaint
- Reflow → Layout 재계산 (비용 높음)
- Repaint → 색상/스타일 변경

---

## ✅ Critical Rendering Path
- CSS는 렌더링 차단 리소스
- JS는 DOM 파싱 차단 가능

### 📌 preload vs prefetch
- preload → 현재 페이지 중요 리소스
- prefetch → 다음 페이지 리소스

### 📌 script async vs defer
- async → 다운로드 후 즉시 실행 (순서 보장 X)
- defer → DOM 파싱 후 실행 (순서 보장)

---

## ✅ 브라우저 저장소

### 📌 localStorage / sessionStorage
- 동기 API
- 5MB 내외 저장
- XSS에 취약

### 📌 IndexedDB
- 비동기
- 대용량 저장 가능
- 트랜잭션 기반

### 📌 쿠키 보안
- HttpOnly
- Secure
- SameSite (Strict / Lax / None)

---

# 3️⃣ React 동작 원리

## ✅ Virtual DOM
- 실제 DOM 변경 최소화
- Diff 알고리즘 기반 비교

## ✅ Reconciliation
- 타입 변경 시 subtree 교체
- key 기반 리스트 최적화

## ✅ Fiber 아키텍처
- 작업을 작은 단위로 분할
- interruptible rendering 가능

## ✅ Concurrent Rendering
- UI 응답성 개선
- 우선순위 기반 렌더링

---

# 4️⃣ Hook 심화

## 📌 useEffect 동작 타이밍
- Commit phase 이후 실행
- cleanup → 다음 effect 실행 전 호출

## 📌 의존성 배열 설계
- 참조 안정성 고려
- ESLint exhaustive-deps 이해

## 📌 useMemo / useCallback 오남용
- 비용보다 메모리 증가가 클 수 있음
- 렌더 최적화 필요 시에만 사용

## 📌 Custom Hook 설계 패턴
- 관심사 분리
- 로직 재사용
- side-effect 캡슐화

---

# 5️⃣ 상태 관리

## 📌 Context API 한계
- 잦은 리렌더
- 복잡한 상태 로직 처리 어려움

## 📌 상태 관리 라이브러리 비교

### 서버 상태 관리
- React Query (TanStack Query)

### 전역 상태 관리
- Redux

### 경량 스토어
- Zustand

## 📌 서버 상태 vs 클라이언트 상태
- 서버 상태 → 캐싱, 동기화, 재요청 관리 필요
- 클라이언트 상태 → UI 상태, 폼 상태 등

---

# 6️⃣ React 성능 최적화

- React.memo
- 적절한 key 전략
- 리스트 가상화
- Code Splitting (dynamic import)
- 번들 분석

---

# 7️⃣ Next.js & SSR 이해

## 📌 SSR vs CSR vs SSG
- SSR → 요청 시 HTML 생성
- CSR → 클라이언트에서 렌더
- SSG → 빌드 시 HTML 생성

## 📌 Hydration
- 서버 HTML에 이벤트 바인딩

## 📌 Streaming SSR
- 부분 스트리밍 응답

## 📌 Edge Runtime
- CDN 엣지에서 실행

## 📌 App Router 구조
- layout.js
- page.js
- loading.js
- error.js

## 📌 Server Component vs Client Component
- Server → 번들 크기 감소
- Client → 상호작용 가능

---

# 8️⃣ TypeScript

## ✅ 타입 시스템

### Generics
- 재사용 가능한 타입

### Utility Types
- Pick
- Omit
- Partial
- Required
- Record

### Conditional Types
- T extends U ? X : Y

### Infer
- 타입 추론 확장

---

## ✅ 실무 패턴

### API 응답 타입 안정성
- Axios/Fetch 제네릭 사용
- DTO 분리

### 공통 타입 설계 전략
- Domain 중심 타입 정의
- Feature 단위 타입 모듈화

### any 지양 전략
- unknown 사용
- 타입 가드 작성

---

# 9️⃣ 아키텍처 & 설계

## 💬 자주 묻는 질문

- 대규모 SPA 구조 어떻게 설계했나요?
- 상태 관리 전략은 어떻게 결정했나요?
- 공통 컴포넌트 설계 원칙은?
- 레거시 개선 경험?
- 성능 개선 사례?

## 📌 설계 시 고려 요소
- 확장성
- 테스트 가능성
- 의존성 분리
- 관심사 분리 (Separation of Concerns)
- 모노레포 vs 멀티레포

---

# 🔟 테스트 전략

## 단위 테스트
- Jest

## 컴포넌트 테스트
- React Testing Library

## E2E
- Cypress
- Playwright

## 테스트 가능한 코드 구조
- 의존성 주입
- Pure function 분리
- Side-effect 분리

---

# 1️⃣1️⃣ 보안

- XSS 방지
- CSRF 방지
- CORS 이해
- OAuth 2.0 인증 흐름

---

# 1️⃣2️⃣ 네트워크 & 성능

## HTTP/1.1 vs HTTP/2
- HTTP/2 → Multiplexing
- Header Compression
- Server Push

## CDN 전략
- Edge 캐싱
- 지역별 응답 최적화

## 캐싱 전략
- Cache-Control
- ETag
- SWR 패턴

## Lighthouse 기반 성능 분석
- LCP
- FID
- CLS
- TTI

---
