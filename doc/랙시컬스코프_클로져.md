````md
# 📘 Lexical Scope & Closure 정리

---

## 📌 Lexical Scope (정적 스코프)

### 🔎 개념
**Lexical Scope**는 함수가 **어디서 호출되었는지**가 아니라  
👉 **어디에 선언되었는지**를 기준으로 스코프가 결정되는 방식이다.

자바스크립트는 **정적 스코프(lexical scope)** 를 따른다.

---

### 🧠 스코프 체인 (Scope Chain)

함수 내부에서 변수를 찾을 때:

1. 현재 스코프에서 찾는다.
2. 없으면 상위(외부) 스코프로 올라간다.
3. 최상위(전역 스코프)까지 탐색한다.
4. 끝까지 없으면 `ReferenceError` 발생

---

### 💻 예제

```javascript
const x = 10;

function outer() {
  const y = 20;

  function inner() {
    console.log(x); // 10 (전역 스코프)
    console.log(y); // 20 (outer 스코프)
  }

  inner();
}

outer();
````

👉 `inner` 함수는 **선언된 위치 기준**으로 `x`, `y`에 접근 가능하다.

---

## 📌 Closure (클로저)

### 🔎 개념

**Closure**는
👉 함수가 선언될 당시의 **외부 변수 환경을 기억하는 함수**

즉, 함수가 외부 스코프에 접근할 수 있고,
그 환경이 함수 실행 이후에도 유지되는 현상이다.

---

### 💻 기본 예제

```javascript
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();

counter(); // 1
counter(); // 2
counter(); // 3
```

👉 `outer()` 실행이 끝났지만
👉 `inner()`는 여전히 `count`를 기억한다.

이것이 **클로저**이다.

---

# 📌 Closure 활용 사례

---

## 1️⃣ 모듈 패턴 (Module Pattern)

외부에서 직접 접근 못 하도록 보호

```javascript
const CounterModule = (function () {
  let count = 0;

  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
})();

CounterModule.increment();
console.log(CounterModule.getCount()); // 1
```

✅ `count`는 외부에서 직접 수정 불가
✅ 캡슐화 + 데이터 보호

---

## 2️⃣ 데이터 은닉 (Data Privacy)

```javascript
function createUser(name) {
  let _name = name;

  return {
    getName() {
      return _name;
    }
  };
}

const user = createUser("Alice");
console.log(user.getName()); // Alice
```

👉 `_name`은 외부에서 직접 접근 불가

---

## 3️⃣ 메모이제이션 (Memoization)

계산 결과를 기억해 성능 최적화

```javascript
function memoizedAdd() {
  const cache = {};

  return function (n) {
    if (cache[n]) {
      return cache[n];
    }

    console.log("계산 중...");
    cache[n] = n + 10;
    return cache[n];
  };
}

const add = memoizedAdd();

add(5); // 계산 중... 15
add(5); // 15 (캐시 사용)
```

✅ 불필요한 재계산 방지
✅ 성능 향상

---

## 4️⃣ 이벤트 핸들러에서 상태 유지

```javascript
function setupButton() {
  let clickCount = 0;

  document.querySelector("button").addEventListener("click", function () {
    clickCount++;
    console.log(`Clicked ${clickCount} times`);
  });
}

setupButton();
```

👉 버튼 클릭 시마다 `clickCount` 유지
👉 클로저 덕분에 상태가 사라지지 않음

---

# 📌 핵심 정리

| 개념            | 설명                           |
| ------------- | ---------------------------- |
| Lexical Scope | 함수 선언 위치 기준 스코프 결정           |
| Scope Chain   | 상위 스코프를 순차적으로 탐색             |
| Closure       | 외부 변수 환경을 기억하는 함수            |
| 활용            | 모듈 패턴, 데이터 은닉, 메모이제이션, 상태 유지 |

---

# 🚀 한 줄 요약

> **Lexical Scope는 "어디에 선언되었는가"이고,
> Closure는 "그 환경을 기억하는 능력"이다.**

```
```
