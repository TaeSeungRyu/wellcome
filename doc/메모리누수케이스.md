---
# 📌 메모리 누수(Memory Leak) 주요 케이스 정리
---

## 1️⃣ 클로저에 불필요한 참조 유지

### 🔎 왜 발생하나?

클로저는 **외부 스코프의 변수를 계속 참조**한다.
그 참조가 남아 있으면 GC(가비지 컬렉션)가 수거하지 못한다.

```js
function createHandler() {
  const largeData = new Array(1000000).fill("data");

  return function () {
    console.log("clicked");
  };
}

const handler = createHandler();
```

위 코드에서 `largeData`는 실제로 사용되지 않지만
클로저 스코프에 남아있기 때문에 메모리에서 해제되지 않을 수 있다.

### 💥 실제로 자주 터지는 케이스

- useEffect 내부에서 대용량 상태 캡처
- 이벤트 핸들러에서 이전 상태 계속 참조
- 오래 유지되는 콜백에 불필요한 객체 포함

### ✅ 방지 방법

- 불필요한 참조 제거
- 필요한 값만 캡처
- 큰 객체는 외부에서 관리
- React에서는 `useCallback`, `useMemo`로 의도적 제어

---

## 2️⃣ 제거되지 않은 이벤트 리스너

### 🔎 왜 발생하나?

이벤트 리스너는 등록한 대상이 살아있는 한 계속 유지된다.

```js
window.addEventListener("resize", handleResize);
```

컴포넌트가 사라져도 `removeEventListener`를 안 하면
핸들러가 계속 살아있다.

### 💥 SPA에서 흔한 문제

- React useEffect cleanup 누락
- Vue onMounted 후 onUnmounted 미사용
- 스크롤, resize, message 이벤트

### ✅ 방지 방법

```js
useEffect(() => {
  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

👉 항상 **등록한 곳에서 반드시 해제**

---

## 3️⃣ 분리된 DOM 노드 참조 유지 (Detached DOM)

### 🔎 왜 발생하나?

DOM에서 제거되었지만
JS에서 참조하고 있으면 GC가 수거하지 못한다.

```js
let element = document.getElementById("box");
document.body.removeChild(element);

// element 변수가 여전히 참조 중
```

이 경우 DOM은 화면에서 사라졌지만
메모리에는 남아 있다.

### 💥 자주 터지는 상황

- 모달을 직접 DOM 조작으로 생성
- third-party 라이브러리
- 캐싱된 노드

### ✅ 방지 방법

- DOM 참조를 null 처리

```js
element = null;
```

- 프레임워크의 lifecycle 활용
- 직접 DOM 조작 최소화

---

## 4️⃣ 타이머 미정리 (setTimeout / setInterval)

### 🔎 왜 발생하나?

타이머는 명시적으로 정리하지 않으면 계속 유지된다.

```js
setInterval(() => {
  console.log("polling...");
}, 1000);
```

컴포넌트가 사라져도 계속 실행된다.

### 💥 실제 문제

- 폴링 API
- debounce 잘못 구현
- 애니메이션 루프

### ✅ 방지 방법

```js
useEffect(() => {
  const timer = setInterval(fetchData, 1000);

  return () => clearInterval(timer);
}, []);
```

---

# 📌 보너스: AbortController 누락

네가 전에 정리했던 AbortController랑 연결되는 부분 👇

```js
useEffect(() => {
  fetch("/api/data"); // 취소 안함
}, []);
```

요청이 끝나기 전에 컴포넌트가 unmount 되면
Promise가 계속 살아있을 수 있다.

### ✅ 해결

```js
useEffect(() => {
  const controller = new AbortController();

  fetch("/api/data", { signal: controller.signal });

  return () => controller.abort();
}, []);
```

---

# 📌 GC 관점에서 이해하기

JS의 GC는 **Reachability(도달 가능성)** 기준이다.

- 루트 객체(window, global)에서
- 참조 그래프를 따라가
- 도달 가능한 객체는 수거하지 않는다

즉,
👉 **어딘가에서 참조하고 있으면 무조건 살아있다**

---

# 📌 실무에서 체크해야 할 것

✅ useEffect cleanup 있는가?
✅ 이벤트 리스너 제거했는가?
✅ 타이머 clear 했는가?
✅ 클로저가 큰 객체를 잡고 있지 않은가?
✅ 외부 라이브러리 destroy 메서드 호출했는가?

---

# 📌 디버깅 방법

Chrome DevTools → Memory 탭

1. Heap snapshot 찍기
2. Detached DOM 검색
3. Retainers 트리 확인

---
